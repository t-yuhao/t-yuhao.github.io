<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>3D 合成大西瓜 - 真实渲染版</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #fff1f6 0%, #ffe4e9 100%);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Microsoft YaHei", sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            padding: env(safe-area-inset-top) 20px 20px 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.1);
            padding: 12px 20px;
        }

        .score-board {
            display: flex;
            flex-direction: column;
        }

        .score-label {
            font-size: 12px;
            color: #888;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        #score-value {
            font-size: 32px;
            font-weight: 800;
            background: linear-gradient(45deg, #ff4081, #ff80ab);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            line-height: 1.1;
        }

        .next-fruit-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 80px;
        }

        .next-label {
            font-size: 10px;
            color: #888;
            margin-bottom: 4px;
            font-weight: 700;
        }

        /* 2D 预览我们也用 Canvas 绘制一个简单的圆 */
        #next-fruit-preview {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #ddd;
            margin-bottom: 4px;
            box-shadow: inset -2px -2px 6px rgba(0,0,0,0.15), 0 4px 8px rgba(0,0,0,0.1);
            border: 2px solid #fff;
            background-size: cover;
        }

        #next-fruit-name {
            font-size: 12px;
            font-weight: bold;
            color: #555;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255,255,255,0.95);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            z-index: 100;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ff4081;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .instructions {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 400px;
            text-align: center;
            pointer-events: auto;
        }

        .instructions-content {
            background: rgba(255,255,255,0.7);
            backdrop-filter: blur(8px);
            padding: 12px 20px;
            border-radius: 50px;
            font-size: 13px;
            color: #555;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            border: 1px solid rgba(255,255,255,0.6);
            line-height: 1.6;
        }
        
        .key-highlight {
            color: #e91e63;
            font-weight: 700;
            margin: 0 2px;
        }
    </style>
</head>
<body>

    <div id="loading">
        <div class="spinner"></div>
        <div style="font-weight:bold; color:#555;">生成纹理中...</div>
    </div>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="glass-panel score-board">
                <div class="score-label">当前分数 SCORE</div>
                <div id="score-value">0</div>
            </div>

            <div class="glass-panel next-fruit-container">
                <div class="next-label">NEXT</div>
                <div id="next-fruit-preview"></div>
                <div id="next-fruit-name">葡萄</div>
            </div>
        </div>

        <div class="instructions">
            <div class="instructions-content">
                <span class="key-highlight">移动</span> 瞄准 &nbsp;•&nbsp; 
                <span class="key-highlight">点击</span> 投放<br>
                <span class="key-highlight">右键/双指</span> 旋转视角
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 纹理生成器 (修复版：每次创建独立 Canvas) ---
        const TextureFactory = {
            size: 512,

            // 辅助方法：创建独立 Canvas
            createCanvas() {
                const canvas = document.createElement('canvas');
                canvas.width = this.size;
                canvas.height = this.size;
                return canvas;
            },

            createNoise(colorBase, colorNoise, density = 50) {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');

                ctx.fillStyle = colorBase;
                ctx.fillRect(0, 0, this.size, this.size);
                
                for (let i = 0; i < density * 100; i++) {
                    const x = Math.random() * this.size;
                    const y = Math.random() * this.size;
                    ctx.fillStyle = colorNoise;
                    ctx.globalAlpha = 0.1 + Math.random() * 0.2;
                    ctx.beginPath();
                    ctx.arc(x, y, 1 + Math.random(), 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1.0;
                
                const tex = new THREE.CanvasTexture(canvas);
                tex.colorSpace = THREE.SRGBColorSpace;
                return tex;
            },

            createStripes(color1, color2, wobble = 5, count = 10) {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');

                // 绘制底色
                ctx.fillStyle = color1;
                ctx.fillRect(0, 0, this.size, this.size);
                
                ctx.fillStyle = color2;
                const stripeWidth = this.size / (count * 2);
                
                for (let i = 0; i < count; i++) {
                    ctx.beginPath();
                    let x = i * stripeWidth * 2 + stripeWidth / 2;
                    ctx.moveTo(x, 0);
                    
                    // 画波浪线
                    for (let y = 0; y <= this.size; y += 10) {
                        let w = Math.sin(y * 0.05) * wobble;
                        ctx.lineTo(x + w, y);
                    }
                    
                    // 回路
                    x += stripeWidth;
                    for (let y = this.size; y >= 0; y -= 10) {
                        let w = Math.sin(y * 0.05) * wobble;
                        ctx.lineTo(x + w, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                
                const tex = new THREE.CanvasTexture(canvas);
                tex.colorSpace = THREE.SRGBColorSpace;
                return tex;
            },
            
            createGrid(color1, color2) {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');

                ctx.fillStyle = color1;
                ctx.fillRect(0, 0, this.size, this.size);
                
                ctx.strokeStyle = color2;
                ctx.lineWidth = 5;
                ctx.beginPath();
                
                const step = this.size / 10;
                // 斜线网格
                for (let i = -this.size; i < this.size * 2; i+=step) {
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i + this.size, this.size);
                    
                    ctx.moveTo(i + this.size, 0);
                    ctx.lineTo(i, this.size);
                }
                ctx.stroke();
                
                const tex = new THREE.CanvasTexture(canvas);
                tex.colorSpace = THREE.SRGBColorSpace;
                return tex;
            },
            
            createSolid(color) {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = color;
                ctx.fillRect(0, 0, this.size, this.size);
                const tex = new THREE.CanvasTexture(canvas);
                tex.colorSpace = THREE.SRGBColorSpace;
                return tex;
            },

            getTexture(type, colorConfig) {
                switch (type) {
                    case 'NOISE':
                        return this.createNoise(colorConfig.base, colorConfig.detail);
                    case 'STRIPE':
                        return this.createStripes(colorConfig.base, colorConfig.detail);
                    case 'GRID':
                        return this.createGrid(colorConfig.base, colorConfig.detail);
                    default:
                        return this.createSolid(colorConfig.base);
                }
            }
        };

        // --- 水果数据配置 ---
        const FRUITS = [
            { level: 0, radius: 0.45, score: 1, name: "葡萄", type: 'NOISE', colors: { base: '#8e24aa', detail: '#4a148c' }, roughness: 0.5 },
            { level: 1, radius: 0.65, score: 2, name: "樱桃", type: 'SMOOTH', colors: { base: '#d50000', detail: '#b71c1c' }, roughness: 0.1, hasStem: true },
            { level: 2, radius: 0.85, score: 4, name: "橘子", type: 'NOISE', colors: { base: '#ff9800', detail: '#ef6c00' }, roughness: 0.8, bumpScale: 0.02 },
            { level: 3, radius: 1.1, score: 6, name: "柠檬", type: 'NOISE', colors: { base: '#fdd835', detail: '#fbc02d' }, roughness: 0.6, scaleY: 1.1 },
            { level: 4, radius: 1.4, score: 8, name: "猕猴桃", type: 'NOISE', colors: { base: '#8d6e63', detail: '#5d4037' }, roughness: 1.0 }, // 毛茸茸
            { level: 5, radius: 1.7, score: 10, name: "番茄", type: 'SMOOTH', colors: { base: '#f44336', detail: '#c62828' }, roughness: 0.2, hasCalyx: true },
            { level: 6, radius: 2.0, score: 12, name: "桃子", type: 'NOISE', colors: { base: '#ffccbc', detail: '#ff8a65' }, roughness: 0.4 },
            { level: 7, radius: 2.4, score: 14, name: "菠萝", type: 'GRID', colors: { base: '#fbc02d', detail: '#f57f17' }, roughness: 0.6 },
            { level: 8, radius: 2.8, score: 16, name: "椰子", type: 'NOISE', colors: { base: '#5d4037', detail: '#3e2723' }, roughness: 0.9 },
            { level: 9, radius: 3.2, score: 18, name: "哈密瓜", type: 'STRIPE', colors: { base: '#c8e6c9', detail: '#a5d6a7' }, roughness: 0.4 },
            { level: 10, radius: 3.6, score: 20, name: "大西瓜", type: 'STRIPE', colors: { base: '#2e7d32', detail: '#1b5e20' }, roughness: 0.3, hasZigzag: true }
        ];

        const BOX_SIZE = { width: 8.5, height: 12, depth: 8.5 };
        const WALL_THICKNESS = 0.5;
        const DROP_HEIGHT = 8.5;
        
        let score = 0;
        let nextFruitLevel = 0;
        let canDrop = true;
        let fruitsInScene = []; 

        let scene, camera, renderer, world, controls;
        let raycaster, mouse;
        let aimLine, aimMarker, shadowMarker;
        let dummyFruit; 
        
        let pointerDownPos = new THREE.Vector2();
        
        // 资源缓存
        let fruitMaterials = []; // 存储生成的材质
        let fruitGeometries = []; // 基础球体几何体
        let physicsMaterial;

        // 通用几何体组件缓存
        const stemGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
        stemGeometry.translate(0, 0.25, 0); // Pivot at bottom
        const calyxGeometry = new THREE.ConeGeometry(0.3, 0.1, 5);
        
        // 材质组件
        const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x33691e, roughness: 0.8 });

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xfff1f6);
            scene.fog = new THREE.Fog(0xfff1f6, 20, 70);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 14, 22);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1, 0);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI / 2 - 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 40;
            controls.mouseButtons = {
                LEFT: null, 
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.ROTATE
            };

            // 光照
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(12, 20, 8);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(2048, 2048);
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 50;
            dirLight.shadow.bias = -0.0005;
            scene.add(dirLight);

            const fillLight = new THREE.DirectionalLight(0xffd1dc, 0.5);
            fillLight.position.set(-10, 10, -5);
            scene.add(fillLight);

            // 物理
            world = new CANNON.World();
            world.gravity.set(0, -18, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.allowSleep = true;

            physicsMaterial = new CANNON.Material('fruit');
            const contactMaterial = new CANNON.ContactMaterial(physicsMaterial, physicsMaterial, {
                friction: 0.3,
                restitution: 0.15
            });
            world.addContactMaterial(contactMaterial);

            // 生成资源
            generateAssets();
            createContainer();
            createAimHelpers();

            // 交互
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            const planeGeo = new THREE.PlaneGeometry(BOX_SIZE.width * 4, BOX_SIZE.depth * 4);
            const planeMat = new THREE.MeshBasicMaterial({ visible: false });
            const mousePlane = new THREE.Mesh(planeGeo, planeMat);
            mousePlane.rotation.x = -Math.PI / 2;
            mousePlane.position.y = DROP_HEIGHT;
            mousePlane.name = "mousePlane";
            scene.add(mousePlane);

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('pointerup', onPointerUp);

            prepareNextFruit();
            document.getElementById('loading').style.display = 'none';
        }

        function generateAssets() {
            FRUITS.forEach(fruit => {
                // 1. 几何体
                let geo = new THREE.SphereGeometry(fruit.radius, 32, 32);
                if (fruit.scaleY) {
                    geo.scale(1, fruit.scaleY, 1);
                }
                fruitGeometries.push(geo);

                // 2. 材质 (程序化纹理)
                const texture = TextureFactory.getTexture(fruit.type, fruit.colors);
                
                const mat = new THREE.MeshStandardMaterial({
                    map: texture,
                    roughness: fruit.roughness,
                    metalness: 0.0,
                    bumpMap: fruit.bumpScale ? texture : null,
                    bumpScale: fruit.bumpScale || 0
                });
                fruitMaterials.push(mat);
            });
        }

        function createContainer() {
            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.1,
                roughness: 0.05,
                transmission: 0.6, 
                thickness: 1.0,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });

            const gridHelper = new THREE.GridHelper(BOX_SIZE.width, 8, 0xff4081, 0xffc1e3);
            gridHelper.position.y = -BOX_SIZE.height/2 + 0.05;
            scene.add(gridHelper);

            // 地板
            createWall(BOX_SIZE.width, WALL_THICKNESS, BOX_SIZE.depth, 0, -BOX_SIZE.height/2, 0, glassMat);
            // 墙壁
            createWall(WALL_THICKNESS, BOX_SIZE.height, BOX_SIZE.depth, -BOX_SIZE.width/2 - WALL_THICKNESS/2, 0, 0, glassMat);
            createWall(WALL_THICKNESS, BOX_SIZE.height, BOX_SIZE.depth, BOX_SIZE.width/2 + WALL_THICKNESS/2, 0, 0, glassMat);
            createWall(BOX_SIZE.width, BOX_SIZE.height, WALL_THICKNESS, 0, 0, -BOX_SIZE.depth/2 - WALL_THICKNESS/2, glassMat);
            createWall(BOX_SIZE.width, BOX_SIZE.height, WALL_THICKNESS, 0, 0, BOX_SIZE.depth/2 + WALL_THICKNESS/2, 
                new THREE.MeshBasicMaterial({ visible: false, transparent: true, opacity: 0 })
            );
            
            // 边框线
            const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(BOX_SIZE.width, BOX_SIZE.height, BOX_SIZE.depth));
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true }));
            scene.add(line);
        }

        function createWall(w, h, d, x, y, z, material) {
            if (material.visible !== false) {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), material);
                mesh.position.set(x, y, z);
                mesh.receiveShadow = false;
                scene.add(mesh);
            }
            const shape = new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2));
            const body = new CANNON.Body({ mass: 0, material: physicsMaterial });
            body.addShape(shape);
            body.position.set(x, y, z);
            world.addBody(body);
        }

        function createAimHelpers() {
            const lineGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, -20, 0)
            ]);
            aimLine = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 }));
            scene.add(aimLine);

            const markerGeo = new THREE.RingGeometry(0.7, 0.8, 32);
            const crossGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-0.8, 0, 0), new THREE.Vector3(0.8, 0, 0),
                new THREE.Vector3(0, -0.8, 0), new THREE.Vector3(0, 0.8, 0)
            ]);
            
            aimMarker = new THREE.Group();
            aimMarker.add(new THREE.Mesh(markerGeo, new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true, side: THREE.DoubleSide })));
            aimMarker.add(new THREE.LineSegments(crossGeo, new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true })));
            aimMarker.rotation.x = -Math.PI / 2;
            aimMarker.position.y = -BOX_SIZE.height/2 + 0.1;
            scene.add(aimMarker);

            shadowMarker = new THREE.Mesh(new THREE.CircleGeometry(1, 32), new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.2, transparent: true }));
            shadowMarker.rotation.x = -Math.PI / 2;
            shadowMarker.position.y = -BOX_SIZE.height/2 + 0.11;
            scene.add(shadowMarker);
        }

        // --- 水果视觉 Mesh 生成工厂 ---
        function createFruitVisual(level) {
            const config = FRUITS[level];
            const group = new THREE.Group(); // 使用组来容纳球体和装饰（如茎）
            
            // 1. 主体球
            const mesh = new THREE.Mesh(fruitGeometries[level], fruitMaterials[level]);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            group.add(mesh);

            // 2. 装饰物 (Stems/Calyx)
            if (config.hasStem) {
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                stem.position.y = config.radius * 0.9;
                // 随机一点倾斜，看起来更自然
                stem.rotation.z = (Math.random() - 0.5) * 0.5;
                stem.castShadow = true;
                group.add(stem);
            }

            if (config.hasCalyx) {
                const calyx = new THREE.Mesh(calyxGeometry, stemMaterial);
                calyx.position.y = config.radius * 0.95;
                calyx.scale.set(1.5, 1, 1.5);
                group.add(calyx);
                
                // 番茄的小把儿
                const smallStem = new THREE.Mesh(stemGeometry, stemMaterial);
                smallStem.position.y = config.radius * 0.95;
                smallStem.scale.set(0.5, 0.5, 0.5);
                group.add(smallStem);
            }

            return group;
        }

        function updateNextFruitUI() {
            nextFruitLevel = Math.floor(Math.random() * 4); 
            const fruitData = FRUITS[nextFruitLevel];
            
            // 更新 DOM 颜色预览
            const preview = document.getElementById('next-fruit-preview');
            preview.style.backgroundColor = fruitData.colors.base;
            document.getElementById('next-fruit-name').innerText = fruitData.name;
            
            // 3D 预览球
            if (dummyFruit) scene.remove(dummyFruit);
            
            // 预览使用简单的 Mesh，为了性能不加装饰
            dummyFruit = createFruitVisual(nextFruitLevel);
            // 预览时半透明
            dummyFruit.children[0].material = dummyFruit.children[0].material.clone();
            dummyFruit.children[0].material.transparent = true;
            dummyFruit.children[0].material.opacity = 0.6;
            
            dummyFruit.position.set(0, DROP_HEIGHT, 0);
            scene.add(dummyFruit);
            
            updateAimHelpers(0, 0);
        }

        function updateAimHelpers(x, z) {
            if (!canDrop) {
                aimLine.visible = false;
                aimMarker.visible = false;
                shadowMarker.visible = false;
                return;
            }
            
            aimLine.visible = true;
            aimMarker.visible = true;
            shadowMarker.visible = true;

            aimLine.position.set(x, DROP_HEIGHT, z);
            const bottomY = -BOX_SIZE.height/2 + 0.1;
            aimMarker.position.set(x, bottomY, z);
            shadowMarker.position.set(x, bottomY + 0.01, z);
            
            const r = FRUITS[nextFruitLevel].radius;
            shadowMarker.scale.set(r, r, 1);
        }

        function prepareNextFruit() {
            updateNextFruitUI();
            canDrop = true;
        }

        function onPointerDown(event) {
            pointerDownPos.set(event.clientX, event.clientY);
        }

        function onPointerMove(event) {
            if (!canDrop) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);
            const hit = intersects.find(obj => obj.object.name === "mousePlane");

            if (hit) {
                const r = FRUITS[nextFruitLevel].radius;
                const x = Math.max(-BOX_SIZE.width/2 + r, Math.min(BOX_SIZE.width/2 - r, hit.point.x));
                const z = Math.max(-BOX_SIZE.depth/2 + r, Math.min(BOX_SIZE.depth/2 - r, hit.point.z));

                if (dummyFruit) dummyFruit.position.set(x, DROP_HEIGHT, z);
                updateAimHelpers(x, z);
            }
        }

        function onPointerUp(event) {
            if (!canDrop || !dummyFruit) return;
            const dist = Math.hypot(event.clientX - pointerDownPos.x, event.clientY - pointerDownPos.y);
            if (dist > 10) return; 

            const x = dummyFruit.position.x;
            const z = dummyFruit.position.z;
            
            dropFruit(x, z, nextFruitLevel);
            
            canDrop = false;
            scene.remove(dummyFruit);
            dummyFruit = null;
            aimLine.visible = false;
            aimMarker.visible = false;
            shadowMarker.visible = false;
            
            setTimeout(prepareNextFruit, 800);
        }

        function dropFruit(x, z, level) {
            const fruitData = FRUITS[level];
            
            // 创建视觉组
            const visualGroup = createFruitVisual(level);
            visualGroup.position.set(x, DROP_HEIGHT, z);
            // 随机初始旋转
            visualGroup.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            scene.add(visualGroup);

            // 创建物理 Body
            const shape = new CANNON.Sphere(fruitData.radius);
            const body = new CANNON.Body({
                mass: 1 * (level + 1),
                material: physicsMaterial,
                position: new CANNON.Vec3(x, DROP_HEIGHT, z),
                quaternion: new CANNON.Quaternion().setFromEuler(visualGroup.rotation.x, visualGroup.rotation.y, visualGroup.rotation.z)
            });
            body.addShape(shape);
            body.linearDamping = 0.4;
            body.angularDamping = 0.4;
            world.addBody(body);

            const fruitObj = { mesh: visualGroup, body, level, id: body.id, isMerging: false };
            fruitsInScene.push(fruitObj);

            body.addEventListener("collide", (e) => {
                handleCollision(fruitObj, e.body);
            });
        }

        function handleCollision(fruitA, bodyB) {
            if (fruitA.isMerging) return;
            const fruitB = fruitsInScene.find(f => f.body === bodyB);
            if (!fruitB || fruitB.isMerging) return;

            if (fruitA.level === fruitB.level) {
                if (fruitA.id < fruitB.id) {
                    mergeFruits(fruitA, fruitB);
                }
            }
        }

        function mergeFruits(fruitA, fruitB) {
            fruitA.isMerging = true;
            fruitB.isMerging = true;

            const midX = (fruitA.body.position.x + fruitB.body.position.x) / 2;
            const midY = (fruitA.body.position.y + fruitB.body.position.y) / 2;
            const midZ = (fruitA.body.position.z + fruitB.body.position.z) / 2;

            removeFruit(fruitA);
            removeFruit(fruitB);

            score += FRUITS[fruitA.level].score * 2;
            const scoreEl = document.getElementById('score-value');
            scoreEl.innerText = score;
            scoreEl.style.transform = "scale(1.5)";
            setTimeout(() => scoreEl.style.transform = "scale(1)", 150);

            const nextLevel = fruitA.level + 1;
            if (nextLevel < FRUITS.length) {
                createMergedFruit(midX, midY, midZ, nextLevel);
            } else {
                score += 100;
                document.getElementById('score-value').innerText = score;
            }
        }

        function createMergedFruit(x, y, z, level) {
            const fruitData = FRUITS[level];
            
            const visualGroup = createFruitVisual(level);
            visualGroup.position.set(x, y, z);
            visualGroup.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            
            visualGroup.scale.set(0.1, 0.1, 0.1);
            let scale = 0.1;
            const growInterval = setInterval(() => {
                scale += 0.15;
                if (scale >= 1.0) {
                    clearInterval(growInterval);
                    visualGroup.scale.set(1,1,1);
                } else {
                    visualGroup.scale.set(scale, scale, scale);
                }
            }, 16);

            scene.add(visualGroup);
            createParticles(x, y, z, fruitData.colors.base);

            const shape = new CANNON.Sphere(fruitData.radius);
            const body = new CANNON.Body({
                mass: 1 * (level + 1),
                material: physicsMaterial,
                position: new CANNON.Vec3(x, y, z),
                quaternion: new CANNON.Quaternion().setFromEuler(visualGroup.rotation.x, visualGroup.rotation.y, visualGroup.rotation.z)
            });
            body.addShape(shape);
            body.linearDamping = 0.4;
            body.angularDamping = 0.4;
            world.addBody(body);

            const fruitObj = { mesh: visualGroup, body, level, id: body.id, isMerging: false };
            fruitsInScene.push(fruitObj);

            body.addEventListener("collide", (e) => {
                handleCollision(fruitObj, e.body);
            });
        }
        
        function createParticles(x, y, z, color) {
            const particleGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const particleMat = new THREE.MeshBasicMaterial({ color: color, transparent: true });
            
            for(let i=0; i<6; i++) {
                const mesh = new THREE.Mesh(particleGeo, particleMat);
                mesh.position.set(x, y, z);
                mesh.position.x += (Math.random() - 0.5);
                mesh.position.y += (Math.random() - 0.5);
                mesh.position.z += (Math.random() - 0.5);
                scene.add(mesh);
                
                let opacity = 1.0;
                const anim = setInterval(() => {
                    opacity -= 0.05;
                    mesh.position.y += 0.05;
                    mesh.rotation.x += 0.1;
                    mesh.rotation.y += 0.1;
                    if(opacity <= 0) {
                        clearInterval(anim);
                        scene.remove(mesh);
                    }
                }, 30);
            }
        }

        function removeFruit(fruitObj) {
            world.removeBody(fruitObj.body);
            scene.remove(fruitObj.mesh);
            const index = fruitsInScene.indexOf(fruitObj);
            if (index > -1) fruitsInScene.splice(index, 1);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            world.step(1 / 60);
            
            if (controls) controls.update();

            for (let i = 0; i < fruitsInScene.length; i++) {
                const f = fruitsInScene[i];
                f.mesh.position.copy(f.body.position);
                f.mesh.quaternion.copy(f.body.quaternion);
                
                if (f.mesh.position.y < -20) {
                    removeFruit(f);
                }
            }

            renderer.render(scene, camera);
        }

    </script>
</body>
</html>