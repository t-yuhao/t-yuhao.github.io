<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>3D 合成大西瓜 - 增强投影版</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #fff1f6 0%, #ffe4e9 100%);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Microsoft YaHei", sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
        }

        /* --- 顶部栏 --- */
        .top-bar {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding-top: max(20px, env(safe-area-inset-top));
            width: 100%;
            pointer-events: auto;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 4px 16px rgba(31, 38, 135, 0.05);
            padding: 8px 20px;
            text-align: center;
            min-width: 90px;
        }

        .score-label { font-size: 12px; color: #888; font-weight: 700; }
        #score-value { font-size: 28px; font-weight: 800; color: #333; line-height: 1.1; }

        .next-preview-box { display: flex; align-items: center; gap: 10px; }
        #next-fruit-preview {
            width: 30px; height: 30px; border-radius: 50%;
            background-color: #ddd; border: 2px solid #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #next-fruit-name { font-size: 14px; font-weight: bold; color: #555; }

        /* --- 侧边栏 --- */
        .side-panel {
            position: absolute; top: 50%; transform: translateY(-50%);
            width: 150px; max-height: 70%; overflow-y: auto;
            pointer-events: auto; padding: 15px;
            display: none; flex-direction: column; gap: 8px;
            scrollbar-width: none; -ms-overflow-style: none;
        }
        .side-panel::-webkit-scrollbar { display: none; }
        .side-left { left: 20px; text-align: left; }
        .side-right { right: 20px; text-align: center; }
        .panel-title { font-size: 14px; font-weight: 900; color: #ff4081; margin-bottom: 8px; text-align: center; }
        .guide-item { display: flex; align-items: center; gap: 8px; background: rgba(255,255,255,0.4); padding: 5px; border-radius: 10px; margin-bottom: 4px; }
        .guide-circle { width: 16px; height: 16px; border-radius: 50%; border: 1px solid #fff; flex-shrink: 0; }
        .guide-name { font-size: 11px; color: #555; font-weight: 600; }
        .guide-score { font-size: 10px; color: #999; margin-left: auto; }
        .instruction-line { font-size: 12px; color: #555; margin-bottom: 6px; line-height: 1.4; }
        .key-highlight { color: #e91e63; font-weight: 800; }

        /* --- 底部提示 --- */
        .mobile-hint {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(255,255,255,0.6); padding: 8px 20px; border-radius: 20px;
            font-size: 12px; color: #666; backdrop-filter: blur(5px);
            white-space: nowrap; pointer-events: none; font-weight: 500;
        }

        /* --- Game Over --- */
        #game-over-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4); backdrop-filter: blur(5px);
            display: none; justify-content: center; align-items: center;
            pointer-events: auto; z-index: 100;
        }
        .modal-content {
            background: white; padding: 30px 50px; border-radius: 30px; text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.2);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .game-over-title { font-size: 24px; font-weight: 900; color: #333; margin-bottom: 10px; }
        .final-score { font-size: 48px; font-weight: 900; color: #ff4081; margin-bottom: 20px; }
        .restart-btn {
            background: linear-gradient(45deg, #ff4081, #ff80ab); color: white; border: none;
            padding: 12px 30px; font-size: 18px; font-weight: bold; border-radius: 50px;
            cursor: pointer; box-shadow: 0 5px 15px rgba(255, 64, 129, 0.3); transition: transform 0.1s;
        }
        .restart-btn:active { transform: scale(0.95); }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; padding: 20px; border-radius: 15px; font-weight: bold; color: #555;
        }

        @media (min-width: 800px) { .side-panel { display: flex; } .mobile-hint { display: none; } }
    </style>
</head>
<body>

    <div id="loading">资源生成中...</div>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="glass-panel score-board">
                <div class="score-label">SCORE</div>
                <div id="score-value">0</div>
            </div>
            <div class="glass-panel next-preview-box">
                <div class="score-label">NEXT</div>
                <div id="next-fruit-preview"></div>
                <div id="next-fruit-name">葡萄</div>
            </div>
        </div>

        <div class="glass-panel side-panel side-left" id="side-left">
            <div class="panel-title">操作说明</div>
            <div class="instruction-line"><span class="key-highlight">单指滑动</span><br>平移水果 (前后左右)</div>
            <div class="instruction-line"><span class="key-highlight">松开手指</span><br>快速投放</div>
            <div class="instruction-line"><span class="key-highlight">双指拖动</span><br>旋转/缩放视角</div>
            <div class="instruction-line" style="margin-top: 8px; color: #ff4081; font-weight: bold;">
                虚线球为落点预判
            </div>
        </div>

        <div class="glass-panel side-panel side-right" id="fruit-guide">
            <div class="panel-title">水果图鉴</div>
        </div>

        <div class="mobile-hint">单指移动 · 双指旋转 · 观察虚线落点</div>

        <div id="game-over-modal">
            <div class="modal-content">
                <div class="game-over-title">游戏结束</div>
                <div class="score-label">最终得分</div>
                <div class="final-score" id="final-score">0</div>
                <button class="restart-btn" id="restart-btn">再来一次</button>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';

        // --- 纹理生成器 ---
        const TextureFactory = {
            size: 256,
            createCanvas() {
                const canvas = document.createElement('canvas');
                canvas.width = this.size; canvas.height = this.size;
                return canvas;
            },
            createNoise(colorBase, colorNoise) {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = colorBase; ctx.fillRect(0, 0, this.size, this.size);
                for (let i = 0; i < 300; i++) {
                    const x = Math.random() * this.size; const y = Math.random() * this.size;
                    ctx.fillStyle = colorNoise; ctx.globalAlpha = 0.15;
                    ctx.beginPath(); ctx.arc(x, y, 1 + Math.random() * 2, 0, Math.PI * 2); ctx.fill();
                }
                return new THREE.CanvasTexture(canvas);
            },
            createStripes(color1, color2) {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = color1; ctx.fillRect(0, 0, this.size, this.size);
                ctx.fillStyle = color2;
                const count = 8; const stripeWidth = this.size / (count * 2);
                for (let i = 0; i < count; i++) {
                    ctx.beginPath();
                    let x = i * stripeWidth * 2 + stripeWidth / 2;
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x + 5, this.size/2); ctx.lineTo(x, this.size);
                    ctx.lineTo(x + stripeWidth, this.size); ctx.lineTo(x + stripeWidth + 5, this.size/2);
                    ctx.lineTo(x + stripeWidth, 0); ctx.fill();
                }
                return new THREE.CanvasTexture(canvas);
            },
            createGrid(color1, color2) {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = color1; ctx.fillRect(0, 0, this.size, this.size);
                ctx.strokeStyle = color2; ctx.lineWidth = 4;
                ctx.beginPath();
                const step = this.size / 6;
                for (let i = 0; i <= this.size; i+=step) {
                    ctx.moveTo(i, 0); ctx.lineTo(i, this.size); ctx.moveTo(0, i); ctx.lineTo(this.size, i);
                }
                ctx.stroke();
                return new THREE.CanvasTexture(canvas);
            },
            createSolid(color) {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = color; ctx.fillRect(0, 0, this.size, this.size);
                return new THREE.CanvasTexture(canvas);
            },
            getTexture(type, colorConfig) {
                let tex;
                switch (type) {
                    case 'NOISE': tex = this.createNoise(colorConfig.base, colorConfig.detail); break;
                    case 'STRIPE': tex = this.createStripes(colorConfig.base, colorConfig.detail); break;
                    case 'GRID': tex = this.createGrid(colorConfig.base, colorConfig.detail); break;
                    default: tex = this.createSolid(colorConfig.base); break;
                }
                tex.colorSpace = THREE.SRGBColorSpace;
                return tex;
            }
        };

        const FRUITS = [
            { level: 0, radius: 0.45, score: 1, name: "葡萄", type: 'NOISE', colors: { base: '#8e24aa', detail: '#4a148c' }, roughness: 0.5 },
            { level: 1, radius: 0.65, score: 2, name: "樱桃", type: 'SMOOTH', colors: { base: '#d50000', detail: '#b71c1c' }, roughness: 0.1, hasStem: true },
            { level: 2, radius: 0.85, score: 4, name: "橘子", type: 'NOISE', colors: { base: '#ff9800', detail: '#ef6c00' }, roughness: 0.8, bumpScale: 0.02 },
            { level: 3, radius: 1.1, score: 6, name: "柠檬", type: 'NOISE', colors: { base: '#fdd835', detail: '#fbc02d' }, roughness: 0.6, scaleY: 1.1 },
            { level: 4, radius: 1.4, score: 8, name: "猕猴桃", type: 'NOISE', colors: { base: '#8d6e63', detail: '#5d4037' }, roughness: 1.0 },
            { level: 5, radius: 1.7, score: 10, name: "番茄", type: 'SMOOTH', colors: { base: '#f44336', detail: '#c62828' }, roughness: 0.2, hasCalyx: true },
            { level: 6, radius: 2.0, score: 12, name: "桃子", type: 'NOISE', colors: { base: '#ffccbc', detail: '#ff8a65' }, roughness: 0.4 },
            { level: 7, radius: 2.4, score: 14, name: "菠萝", type: 'GRID', colors: { base: '#fbc02d', detail: '#f57f17' }, roughness: 0.6 },
            { level: 8, radius: 2.8, score: 16, name: "椰子", type: 'NOISE', colors: { base: '#5d4037', detail: '#3e2723' }, roughness: 0.9 },
            { level: 9, radius: 3.2, score: 18, name: "哈密瓜", type: 'STRIPE', colors: { base: '#c8e6c9', detail: '#a5d6a7' }, roughness: 0.4 },
            { level: 10, radius: 3.6, score: 20, name: "大西瓜", type: 'STRIPE', colors: { base: '#2e7d32', detail: '#1b5e20' }, roughness: 0.3, hasZigzag: true }
        ];

        const BOX_SIZE = { width: 8.5, height: 16, depth: 8.5 };
        const WALL_THICKNESS = 0.5;
        const DROP_HEIGHT = 12; 
        const LIMIT_LINE_Y = BOX_SIZE.height / 2 - 1.0;
        
        let score = 0;
        let nextFruitLevel = 0;
        let canDrop = true;
        let isGameOver = false;
        let fruitsInScene = []; 

        let scene, camera, renderer, world, controls;
        let aimLine, ghostFruit, shadowMarker, rangeRing; // 辅助对象
        let dummyFruit; 
        
        let isDragging = false;
        let lastPointer = new THREE.Vector2();
        let currentFruitPos = new THREE.Vector3(0, DROP_HEIGHT, 0);

        let fruitMaterials = [];
        let fruitGeometries = [];
        let physicsMaterial;
        const stemGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
        stemGeometry.translate(0, 0.25, 0);
        const calyxGeometry = new THREE.ConeGeometry(0.3, 0.1, 5);
        const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x33691e, roughness: 0.8 });
        
        // 用于射线检测的数组
        let dropTargets = []; // 包含地板和所有水果 Mesh
        let raycasterDown; // 垂直射线
        let floorMesh; // 不可见的地板 Mesh

        function renderFruitGuide() {
            const container = document.getElementById('fruit-guide');
            container.innerHTML = '<div class="panel-title">水果图鉴</div>';
            FRUITS.slice().reverse().forEach(fruit => {
                const item = document.createElement('div');
                item.className = 'guide-item';
                item.innerHTML = `
                    <div class="guide-circle" style="background-color: ${fruit.colors.base}"></div>
                    <div class="guide-name">${fruit.name}</div>
                    <div class="guide-score">${fruit.score}</div>
                `;
                container.appendChild(item);
            });
        }

        init();
        renderFruitGuide();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xfff1f6);
            scene.fog = new THREE.Fog(0xfff1f6, 25, 80);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 22, 28);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFShadowMap; 
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(512, 512);
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 50;
            scene.add(dirLight);

            world = new CANNON.World();
            world.gravity.set(0, -40, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.allowSleep = true;

            physicsMaterial = new CANNON.Material('fruit');
            world.addContactMaterial(new CANNON.ContactMaterial(physicsMaterial, physicsMaterial, { friction: 0.3, restitution: 0.1 }));

            generateAssets();
            createContainer();
            createAimHelpers();
            
            // 初始化射线
            raycasterDown = new THREE.Raycaster();
            raycasterDown.ray.direction.set(0, -1, 0);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 2, 0);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.1;
            
            controls.mouseButtons = {
                LEFT: null, 
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.ROTATE
            };
            controls.touches = {
                ONE: null,
                TWO: THREE.TOUCH.ROTATE
            };

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('pointerdown', onPointerDown, { passive: false });
            window.addEventListener('pointermove', onPointerMove, { passive: false });
            window.addEventListener('pointerup', onPointerUp);

            document.getElementById('restart-btn').addEventListener('click', restartGame);

            prepareNextFruit();
            document.getElementById('loading').style.display = 'none';
        }

        function generateAssets() {
            FRUITS.forEach(fruit => {
                let geo = new THREE.SphereGeometry(fruit.radius, 32, 32);
                if (fruit.scaleY) geo.scale(1, fruit.scaleY, 1);
                fruitGeometries.push(geo);

                const texture = TextureFactory.getTexture(fruit.type, fruit.colors);
                const mat = new THREE.MeshStandardMaterial({
                    map: texture, 
                    roughness: fruit.roughness, 
                    metalness: 0.1,
                    bumpMap: fruit.bumpScale ? texture : null, 
                    bumpScale: fruit.bumpScale || 0
                });
                fruitMaterials.push(mat);
            });
        }

        function createContainer() {
            const glassMat = new THREE.MeshStandardMaterial({
                color: 0xffffff, 
                roughness: 0.1,
                metalness: 0.1,
                transparent: true, 
                opacity: 0.25, 
                side: THREE.DoubleSide
            });

            const gridHelper = new THREE.GridHelper(BOX_SIZE.width, 8, 0xff4081, 0xffc1e3);
            gridHelper.position.y = -BOX_SIZE.height/2 + 0.05;
            scene.add(gridHelper);

            // 底部物理墙和不可见检测地板
            createWall(BOX_SIZE.width, WALL_THICKNESS, BOX_SIZE.depth, 0, -BOX_SIZE.height/2, 0, glassMat);
            
            // 专门用于射线检测的地板 Mesh (稍微高于物理地板，防止 z-fight)
            floorMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(BOX_SIZE.width - 0.2, BOX_SIZE.depth - 0.2), 
                new THREE.MeshBasicMaterial({ visible: false })
            );
            floorMesh.rotation.x = -Math.PI / 2;
            floorMesh.position.y = -BOX_SIZE.height/2 + WALL_THICKNESS/2;
            scene.add(floorMesh);
            dropTargets.push(floorMesh); // 加入检测列表

            createWall(WALL_THICKNESS, BOX_SIZE.height, BOX_SIZE.depth, -BOX_SIZE.width/2 - WALL_THICKNESS/2, 0, 0, glassMat);
            createWall(WALL_THICKNESS, BOX_SIZE.height, BOX_SIZE.depth, BOX_SIZE.width/2 + WALL_THICKNESS/2, 0, 0, glassMat);
            createWall(BOX_SIZE.width, BOX_SIZE.height, WALL_THICKNESS, 0, 0, -BOX_SIZE.depth/2 - WALL_THICKNESS/2, glassMat);
            createWall(BOX_SIZE.width, BOX_SIZE.height, WALL_THICKNESS, 0, 0, BOX_SIZE.depth/2 + WALL_THICKNESS/2, 
                new THREE.MeshBasicMaterial({ visible: false, transparent: true, opacity: 0 })
            );

            const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(BOX_SIZE.width, BOX_SIZE.height, BOX_SIZE.depth));
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.4, transparent: true }));
            scene.add(line);

            const planeGeo = new THREE.PlaneGeometry(BOX_SIZE.width, BOX_SIZE.depth);
            const planeMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.15, side: THREE.DoubleSide, depthWrite: false });
            const limitPlane = new THREE.Mesh(planeGeo, planeMat);
            limitPlane.rotation.x = -Math.PI / 2;
            limitPlane.position.y = LIMIT_LINE_Y;
            scene.add(limitPlane);
            
            const borderGeo = new THREE.EdgesGeometry(planeGeo);
            const borderMat = new THREE.LineBasicMaterial({ color: 0xff0000, opacity: 0.5, transparent: true });
            const border = new THREE.LineSegments(borderGeo, borderMat);
            border.rotation.x = -Math.PI / 2;
            border.position.y = LIMIT_LINE_Y;
            scene.add(border);
        }

        function createWall(w, h, d, x, y, z, material) {
            if (material.visible !== false) {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), material);
                mesh.position.set(x, y, z);
                mesh.receiveShadow = false;
                scene.add(mesh);
            }
            const shape = new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2));
            const body = new CANNON.Body({ mass: 0, material: physicsMaterial });
            body.addShape(shape);
            body.position.set(x, y, z);
            world.addBody(body);
        }

        function createAimHelpers() {
            // 1. 垂直连线 (从手上的球连到 Ghost)
            const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, -25, 0)]);
            aimLine = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3, dashSize: 0.5, gapSize: 0.2 }));
            aimLine.computeLineDistances(); // 启用虚线
            scene.add(aimLine);

            // 2. 虚线预判球 (Ghost Fruit)
            // 使用 WireframeGeometry 创建纯线框球体
            // 初始化时随便用一个几何体，update 时会换
            ghostFruit = new THREE.Group();
            scene.add(ghostFruit);

            // 3. 底部阴影与范围环
            shadowMarker = new THREE.Mesh(new THREE.CircleGeometry(1, 32), new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.3, transparent: true }));
            shadowMarker.rotation.x = -Math.PI / 2;
            scene.add(shadowMarker);

            const ringGeo = new THREE.RingGeometry(0.9, 1.0, 64);
            rangeRing = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({ color: 0xffeb3b, opacity: 0.8, transparent: true, side: THREE.DoubleSide }));
            rangeRing.rotation.x = -Math.PI / 2;
            scene.add(rangeRing);
        }

        function createFruitVisual(level) {
            const config = FRUITS[level];
            const group = new THREE.Group();
            const mesh = new THREE.Mesh(fruitGeometries[level], fruitMaterials[level]);
            mesh.castShadow = true; mesh.receiveShadow = true;
            group.add(mesh);
            if (config.hasStem) {
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                stem.position.y = config.radius * 0.9; stem.rotation.z = (Math.random() - 0.5) * 0.5; stem.castShadow = true; group.add(stem);
            }
            if (config.hasCalyx) {
                const calyx = new THREE.Mesh(calyxGeometry, stemMaterial);
                calyx.position.y = config.radius * 0.95; calyx.scale.set(1.5, 1, 1.5); group.add(calyx);
                const smallStem = new THREE.Mesh(stemGeometry, stemMaterial);
                smallStem.position.y = config.radius * 0.95; smallStem.scale.set(0.5, 0.5, 0.5); group.add(smallStem);
            }
            return group;
        }

        // 更新虚线球的几何体以匹配当前水果
        function updateGhostGeometry(level) {
            // 清除旧的 Ghost
            while(ghostFruit.children.length > 0){ 
                const child = ghostFruit.children[0];
                if (child.geometry) child.geometry.dispose();
                ghostFruit.remove(child); 
            }

            const fruitData = FRUITS[level];
            const geometry = fruitGeometries[level];
            
            // 创建虚线球
            const wireframe = new THREE.WireframeGeometry(geometry);
            const line = new THREE.LineSegments(wireframe);
            line.material = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 });
            
            // 再加一个稍微透明的实体球，增加体积感
            const fillMesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: fruitData.colors.base, transparent: true, opacity: 0.15, wireframe: false }));

            ghostFruit.add(line);
            ghostFruit.add(fillMesh);
        }

        function updateNextFruitUI() {
            nextFruitLevel = Math.floor(Math.random() * 4); 
            const fruitData = FRUITS[nextFruitLevel];
            
            const preview = document.getElementById('next-fruit-preview');
            preview.style.backgroundColor = fruitData.colors.base;
            document.getElementById('next-fruit-name').innerText = fruitData.name;
            
            if (dummyFruit) scene.remove(dummyFruit);
            dummyFruit = createFruitVisual(nextFruitLevel);
            dummyFruit.children[0].material = dummyFruit.children[0].material.clone();
            dummyFruit.children[0].material.transparent = true;
            dummyFruit.children[0].material.opacity = 0.8;
            
            currentFruitPos.set(0, DROP_HEIGHT, 0);
            dummyFruit.position.copy(currentFruitPos);
            scene.add(dummyFruit);

            // 更新 Ghost 样式
            updateGhostGeometry(nextFruitLevel);
            
            updateAimHelpers();
        }

        function updateAimHelpers() {
            if (!canDrop || isGameOver) {
                aimLine.visible = false; ghostFruit.visible = false; 
                shadowMarker.visible = false; rangeRing.visible = false;
                return;
            }
            aimLine.visible = true; ghostFruit.visible = true; 
            shadowMarker.visible = true; rangeRing.visible = true;
            
            const { x, y, z } = currentFruitPos;
            const r = FRUITS[nextFruitLevel].radius;

            // --- 射线检测逻辑 ---
            raycasterDown.ray.origin.set(x, y, z);
            // 检测列表：地板 + 场景内所有水果 Mesh
            const targets = [floorMesh, ...fruitsInScene.map(f => f.mesh.children[0])]; // children[0] 是主球体
            
            const hits = raycasterDown.intersectObjects(targets, false);
            
            let dropY = -BOX_SIZE.height/2 + r; // 默认地板高度

            if (hits.length > 0) {
                // 找到最高的接触点
                // 射线是向下的，第一个 hit 就是最高的物体
                dropY = hits[0].point.y + r;
            }

            // 1. 设置 Ghost 位置
            ghostFruit.position.set(x, dropY, z);

            // 2. 连线：从手上的球 -> Ghost 球中心
            const positions = aimLine.geometry.attributes.position.array;
            positions[0] = x; positions[1] = y; positions[2] = z; // 起点
            positions[3] = x; positions[4] = dropY; positions[5] = z; // 终点
            aimLine.geometry.attributes.position.needsUpdate = true;

            // 3. 底部光圈和阴影 (贴在接触面上)
            // 接触面 Y = dropY - r
            const contactY = dropY - r + 0.02; // 稍微抬高一点防 z-fight
            
            shadowMarker.position.set(x, contactY, z);
            shadowMarker.scale.set(r, r, 1);

            rangeRing.position.set(x, contactY, z);
            rangeRing.scale.set(r, r, 1);
        }

        function prepareNextFruit() {
            if(isGameOver) return;
            updateNextFruitUI();
            canDrop = true;
        }

        function onPointerDown(event) {
            if (!canDrop || isGameOver) return;
            if (event.isPrimary === false) return; 
            
            isDragging = true;
            lastPointer.set(event.clientX, event.clientY);
        }

        function onPointerMove(event) {
            if (!isDragging || !canDrop || isGameOver) return;
            
            const dx = event.clientX - lastPointer.x;
            const dy = event.clientY - lastPointer.y;
            lastPointer.set(event.clientX, event.clientY);

            const sensitivity = 20.0 / window.innerWidth; 

            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

            // 修正逻辑：屏幕向下移动 (dy > 0) -> 拉近 -> 沿着 forward 的反方向移动 (如果 forward 是指向屏幕内)
            // 实际上 OrbitControls 的 forward 矢量指向目标。
            // 如果想让鼠标下拉物体靠近自己，即沿着 Camera -> Target 的反方向。
            // 所以应该是 -dy
            const moveDelta = new THREE.Vector3()
                .addScaledVector(right, dx * sensitivity)
                .addScaledVector(forward, -dy * sensitivity); 

            currentFruitPos.add(moveDelta);

            const r = FRUITS[nextFruitLevel].radius;
            const limitX = BOX_SIZE.width / 2 - r;
            const limitZ = BOX_SIZE.depth / 2 - r;
            
            currentFruitPos.x = Math.max(-limitX, Math.min(limitX, currentFruitPos.x));
            currentFruitPos.z = Math.max(-limitZ, Math.min(limitZ, currentFruitPos.z));
            
            if (dummyFruit) {
                dummyFruit.position.copy(currentFruitPos);
                updateAimHelpers(); // 实时计算射线
            }
        }

        function onPointerUp(event) {
            if (!isDragging) return;
            isDragging = false;

            if (!canDrop || isGameOver) return;
            dropFruit(currentFruitPos.x, currentFruitPos.z, nextFruitLevel);
            canDrop = false;
            scene.remove(dummyFruit);
            dummyFruit = null;
            updateAimHelpers();
            setTimeout(prepareNextFruit, 600);
        }

        function dropFruit(x, z, level) {
            const fruitData = FRUITS[level];
            const visualGroup = createFruitVisual(level);
            visualGroup.position.set(x, DROP_HEIGHT, z);
            visualGroup.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            scene.add(visualGroup);

            const shape = new CANNON.Sphere(fruitData.radius);
            const body = new CANNON.Body({
                mass: 1 * (level + 1), material: physicsMaterial,
                position: new CANNON.Vec3(x, DROP_HEIGHT, z),
                quaternion: new CANNON.Quaternion().setFromEuler(visualGroup.rotation.x, visualGroup.rotation.y, visualGroup.rotation.z)
            });
            body.addShape(shape);
            body.linearDamping = 0.4; body.angularDamping = 0.4;
            body.velocity.set(0, -15, 0);
            world.addBody(body);
            body.safeFrames = 60;

            const fruitObj = { mesh: visualGroup, body, level, id: body.id, isMerging: false };
            fruitsInScene.push(fruitObj);

            body.addEventListener("collide", (e) => handleCollision(fruitObj, e.body));
        }

        function handleCollision(fruitA, bodyB) {
            if (fruitA.isMerging || isGameOver) return;
            const fruitB = fruitsInScene.find(f => f.body === bodyB);
            if (!fruitB || fruitB.isMerging) return;
            if (fruitA.level === fruitB.level && fruitA.id < fruitB.id) {
                mergeFruits(fruitA, fruitB);
            }
        }

        function mergeFruits(fruitA, fruitB) {
            fruitA.isMerging = true; fruitB.isMerging = true;
            const midX = (fruitA.body.position.x + fruitB.body.position.x) / 2;
            const midY = (fruitA.body.position.y + fruitB.body.position.y) / 2;
            const midZ = (fruitA.body.position.z + fruitB.body.position.z) / 2;
            removeFruit(fruitA); removeFruit(fruitB);
            score += FRUITS[fruitA.level].score * 2;
            updateScoreUI();
            const nextLevel = fruitA.level + 1;
            if (nextLevel < FRUITS.length) createMergedFruit(midX, midY, midZ, nextLevel);
            else { score += 100; updateScoreUI(); }
        }

        function createMergedFruit(x, y, z, level) {
            const fruitData = FRUITS[level];
            const visualGroup = createFruitVisual(level);
            visualGroup.position.set(x, y, z);
            scene.add(visualGroup);
            visualGroup.scale.set(0.1, 0.1, 0.1);
            let scale = 0.1;
            const growInterval = setInterval(() => {
                scale += 0.2;
                if (scale >= 1.0) { clearInterval(growInterval); visualGroup.scale.set(1,1,1); } 
                else visualGroup.scale.set(scale, scale, scale);
            }, 16);

            const shape = new CANNON.Sphere(fruitData.radius);
            const body = new CANNON.Body({
                mass: 1 * (level + 1), material: physicsMaterial,
                position: new CANNON.Vec3(x, y, z),
                quaternion: new CANNON.Quaternion().setFromEuler(visualGroup.rotation.x, visualGroup.rotation.y, visualGroup.rotation.z)
            });
            body.addShape(shape);
            body.linearDamping = 0.4; body.angularDamping = 0.4;
            world.addBody(body);
            body.safeFrames = 30;

            const fruitObj = { mesh: visualGroup, body, level, id: body.id, isMerging: false };
            fruitsInScene.push(fruitObj);
            body.addEventListener("collide", (e) => handleCollision(fruitObj, e.body));
        }

        function removeFruit(fruitObj) {
            world.removeBody(fruitObj.body);
            scene.remove(fruitObj.mesh);
            const index = fruitsInScene.indexOf(fruitObj);
            if (index > -1) fruitsInScene.splice(index, 1);
        }

        function updateScoreUI() {
            const scoreEl = document.getElementById('score-value');
            scoreEl.innerText = score;
            scoreEl.style.transform = "scale(1.5)";
            setTimeout(() => scoreEl.style.transform = "scale(1)", 150);
        }

        function checkGameOver() {
            if (isGameOver) return;
            for (let i = 0; i < fruitsInScene.length; i++) {
                const f = fruitsInScene[i];
                if (f.body.safeFrames > 0) { f.body.safeFrames--; continue; }
                if (f.body.position.y > LIMIT_LINE_Y) {
                    const speed = f.body.velocity.length();
                    if (speed < 0.15) { triggerGameOver(); break; }
                }
            }
        }

        function triggerGameOver() {
            isGameOver = true;
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over-modal').style.display = 'flex';
        }

        function restartGame() {
            for (let i = fruitsInScene.length - 1; i >= 0; i--) removeFruit(fruitsInScene[i]);
            fruitsInScene = [];
            score = 0; updateScoreUI();
            isGameOver = false;
            document.getElementById('game-over-modal').style.display = 'none';
            controls.reset();
            prepareNextFruit();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!isGameOver) { world.step(1 / 60); checkGameOver(); }
            if (controls) controls.update();
            for (let i = 0; i < fruitsInScene.length; i++) {
                const f = fruitsInScene[i];
                f.mesh.position.copy(f.body.position);
                f.mesh.quaternion.copy(f.body.quaternion);
                if (f.mesh.position.y < -30) removeFruit(f);
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>