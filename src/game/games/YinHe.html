<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>3D Milky Way Galaxy</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #canvas-container { width: 100vw; height: 100vh; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: sans-serif; pointer-events: none;
            text-align: center;
        }
        .controls-info {
            position: absolute; bottom: 20px; left: 20px;
            color: rgba(255,255,255,0.5); font-family: sans-serif; font-size: 14px; pointer-events: none;
        }
        .title {
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.8); font-family: 'Segoe UI', sans-serif; 
            font-size: 24px; pointer-events: none; letter-spacing: 4px; font-weight: 300;
            text-shadow: 0 0 10px rgba(255, 100, 50, 0.5);
        }
    </style>
    <!-- 引入 Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div class="title">MILKY WAY</div>
    <div id="loading">正在生成数万颗恒星...</div>
    <div id="canvas-container"></div>
    <div class="controls-info">左键旋转 | 右键平移 | 滚轮缩放 | 双击全屏</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. 场景初始化 ---
        const scene = new THREE.Scene();
        // 极深的蓝黑色背景，模拟深空
        scene.background = new THREE.Color('#010103'); 

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 35); // 初始视角

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 性能优化
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- 2. 控制器 ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true; // 自动旋转相机
        controls.autoRotateSpeed = 0.5;

        // --- 3. 银河系参数配置 ---
        const parameters = {
            count: 80000,           // 粒子数量
            size: 0.015,            // 粒子大小
            radius: 20,             // 银河系半径
            branches: 3,            // 旋臂数量
            spin: 1,                // 旋臂弯曲程度
            randomness: 0.2,        // 粒子位置随机度
            randomnessPower: 3,     // 随机分布指数 (越高越聚集在轨道线上)
            insideColor: '#ff6030', // 核心颜色 (暖橙色)
            outsideColor: '#1b3984' // 边缘颜色 (深蓝色)
        };

        let geometry = null;
        let material = null;
        let points = null;

        // --- 4. 生成银河系的核心函数 ---
        const generateGalaxy = () => {
            // 如果已有几何体，先释放内存
            if(points !== null) {
                geometry.dispose();
                material.dispose();
                scene.remove(points);
            }

            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(parameters.count * 3);
            const colors = new Float32Array(parameters.count * 3);

            const colorInside = new THREE.Color(parameters.insideColor);
            const colorOutside = new THREE.Color(parameters.outsideColor);

            for(let i = 0; i < parameters.count; i++) {
                const i3 = i * 3;

                // 半径：随机分布在 0 到最大半径之间
                const radius = Math.random() * parameters.radius;
                
                // 旋臂角度：(索引 % 分支数) / 分支数 * 2PI
                const spinAngle = radius * parameters.spin;
                const branchAngle = (i % parameters.branches) / parameters.branches * Math.PI * 2;
                
                // 随机偏移 (制造云雾感)
                // 使用 power 使得粒子更多聚集在中心轴线附近
                const randomX = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * radius;
                const randomY = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * radius;
                const randomZ = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * radius;

                // 最终位置
                positions[i3    ] = Math.cos(branchAngle + spinAngle) * radius + randomX; // x
                positions[i3 + 1] = randomY; // y (厚度)
                positions[i3 + 2] = Math.sin(branchAngle + spinAngle) * radius + randomZ; // z

                // 颜色混合
                // 核心是混合色，越往外越偏向 outsideColor
                const mixedColor = colorInside.clone();
                mixedColor.lerp(colorOutside, radius / parameters.radius);

                colors[i3    ] = mixedColor.r;
                colors[i3 + 1] = mixedColor.g;
                colors[i3 + 2] = mixedColor.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // 材质
            material = new THREE.PointsMaterial({
                size: parameters.size,
                sizeAttenuation: true, // 粒子远小近大
                depthWrite: false,     // 关闭深度写入，允许粒子叠加发光
                blending: THREE.AdditiveBlending, // 加法混合，越重叠越亮
                vertexColors: true     // 使用顶点颜色
            });

            // 生成星空纹理 (可选，这里直接用点)
            // 如果想要更好看，可以加载一个圆形辉光贴图，但原生点在加法混合下效果也不错

            points = new THREE.Points(geometry, material);
            scene.add(points);
        }

        generateGalaxy();

        // --- 5. 背景辅助恒星 (让宇宙不那么空) ---
        const bgStarsCount = 2000;
        const bgGeometry = new THREE.BufferGeometry();
        const bgPos = new Float32Array(bgStarsCount * 3);
        for(let i=0; i<bgStarsCount*3; i++) {
            bgPos[i] = (Math.random() - 0.5) * 100; // 远距离背景
        }
        bgGeometry.setAttribute('position', new THREE.BufferAttribute(bgPos, 3));
        const bgMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.05,
            transparent: true,
            opacity: 0.6
        });
        const bgStars = new THREE.Points(bgGeometry, bgMaterial);
        scene.add(bgStars);


        // --- 6. 动画循环 ---
        const clock = new THREE.Clock();

        const tick = () => {
            const elapsedTime = clock.getElapsedTime();

            // 银河系自转
            points.rotation.y = elapsedTime * 0.05;
            
            // 背景微动
            bgStars.rotation.y = elapsedTime * 0.005;

            controls.update();
            renderer.render(scene, camera);
            window.requestAnimationFrame(tick);
        }

        tick();

        document.getElementById('loading').style.display = 'none';

        // --- 窗口自适应 ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        });

        // 双击全屏
        window.addEventListener('dblclick', () => {
            const fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement;
            if(!fullscreenElement) {
                if(document.body.requestFullscreen) document.body.requestFullscreen();
                else if(document.body.webkitRequestFullscreen) document.body.webkitRequestFullscreen();
            } else {
                if(document.exitFullscreen) document.exitFullscreen();
                else if(document.webkitExitFullscreen) document.webkitExitFullscreen();
            }
        });

    </script>
</body>
</html>